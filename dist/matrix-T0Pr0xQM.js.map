{"version":3,"file":"matrix-T0Pr0xQM.js","sources":["../src/math/geometry.ts","../src/math/point.ts","../src/math/matrix.ts"],"sourcesContent":["import { Point } from \"./point\"\n\nexport type LineEquation = { m: number, c: number }\nexport const lineEquation = (p1: Point, p2: Point): LineEquation => {\n    const m = (p2.y - p1.y) / (p2.x - p1.x)\n    const c = p1.y - m * p1.x\n    return { m, c }\n}\nexport const linesDistance = (l1: LineEquation, l2: LineEquation) => {\n    return Math.abs(l2.c - l1.c) / Math.sqrt(1 + l1.m ** 2)\n}\nexport const distancePointFromLine = (p: Point, ls: Point, le: Point) => {\n    return (\n        (le.x - ls.x) * (ls.y - p.y) - (le.y - ls.y) * (ls.x - p.x)\n    ) / Math.sqrt((le.x - ls.x) ** 2 + (le.y - ls.y) ** 2)\n}\nexport const reflectPointOverLine = (line: LineEquation, point: Point) => {\n    return {\n        x: (point.x + line.m * (point.y - line.c)) / (1 + line.m ** 2),\n        y: (line.m * point.x - point.y + 2 * line.c) / (1 + line.m ** 2),\n    }\n}","export interface Point { x: number, y: number }\nexport function point(value: [number, number]): Point\nexport function point(value: Point): Point\nexport function point(x: number, y: number): Point\nexport function point() {\n    return arguments.length === 1 ?\n        Array.isArray(arguments[0]) ? Object.freeze({ x: arguments[0][0], y: arguments[0][1] })\n            : Object.freeze({ x: arguments[0].x, y: arguments[0].y })\n        :\n        Object.freeze({ x: arguments[0], y: arguments[1] })\n}\nexport const zeroAjsPoint = (point: Point) => {\n    const NEAR_ZERO = 1e-10\n\n    return Object.freeze({\n        x: Math.abs(point.x) < NEAR_ZERO ? 0 : point.x,\n        y: Math.abs(point.y) < NEAR_ZERO ? 0 : point.y,\n    })\n}\nexport enum CmpPoint {\n    LESS = -1,\n    EQUAL = 0,\n    MORE = 1,\n    OTHER = 2,\n}\nexport const cmpPoint = (p1: Point, p2: Point) => (p1.x === p2.x && p1.y === p2.y) ?\n    CmpPoint.EQUAL : (p1.x > p2.x && p1.y > p2.y) ?\n        CmpPoint.MORE : (p1.x < p2.x && p1.y < p2.y) ?\n            CmpPoint.LESS : CmpPoint.OTHER\nexport const roundPoint = (point: Point) => Object.freeze({ x: Math.round(point.x), y: Math.round(point.y) })\nexport const absPoint = (point: Point) => Object.freeze({ x: Math.abs(point.x), y: Math.abs(point.y) })\nexport const addPoint = (p2: Point, p1: Point) => Object.freeze({ x: p2.x + p1.x, y: p2.y + p1.y })\nexport const subPoint = (p2: Point, p1: Point) => Object.freeze({ x: p2.x - p1.x, y: p2.y - p1.y })\nexport const divPoint = (p2: Point, p1: Point) => Object.freeze({ x: p2.x / p1.x, y: p2.y / p1.y })\nexport const mulPoint = (p2: Point, p1: Point) => Object.freeze({ x: p2.x * p1.x, y: p2.y * p1.y })\nexport const rotatePoint = (point: Point, angle: number, origin: Point) => {\n    const radians = (Math.PI / 180) * angle\n    const cos = Math.cos(radians)\n    const sin = Math.sin(radians)\n\n    return Object.freeze({\n        x: cos * (point.x - origin.x) + sin * (point.y - origin.y) + origin.x,\n        y: cos * (point.y - origin.y) - sin * (point.x - origin.x) + origin.y\n    })\n}\nexport const rotatePoints = (points: Point[], angle: number, origin: Point) => {\n    return points.map(point => rotatePoint(point, angle, origin))\n}","import { point, Point, rotatePoints } from './point'\n\n/**\n * Mathematical utilities.\n * @module math\n * @license MIT\n *\n * @copyright 2010 Alexis Deveria, 2010 Jeff Schiller\n */\n\n/**\n * @typedef {PlainObject} module:math.AngleCoord45\n * @property {Float} x - The angle-snapped x value\n * @property {Float} y - The angle-snapped y value\n * @property {Integer} a - The angle at which to snap\n */\n\n/**\n * @typedef {PlainObject} module:math.XYObject\n * @property {Float} x\n * @property {Float} y\n */\n\n// Constants\nconst NEAR_ZERO = 1e-14\n\n\n/**\n * A (hopefully) quicker function to transform a point by a matrix\n * (this function avoids any DOM calls and just does the math).\n * @function module:math.transformPoint\n * @param {Point} point - Float representing the x coordinate\n * @param {DOMMatrix} m - Matrix object to transform the point with\n * @returns {module:Point} representing the transformed point\n */\nexport const transformPoint = (m: DOMMatrix, p: Point) =>\n    point(m.a * p.x + m.c * p.y + m.e, m.b * p.x + m.d * p.y + m.f)\n\n/**\n * Calculate an array of points transformed with an affine matrix\n * @function module:math.transformPoints\n * @param {DOMMatrix} matrix Affine Matrix\n * @param {Point[]} points Array of point\n * @returns {Point[]} Array of point\n */\nexport const transformPoints = (m: DOMMatrix, points: Point[]) => {\n    return points.map(point => transformPoint(m, point))\n}\n\n/**\n * Helper function to check if the matrix performs no actual transform\n * (i.e. exists for identity purposes).\n * @function module:math.isIdentity\n * @param {DOMMatrix} m - The matrix object to check\n * @returns {boolean} Indicates whether or not the matrix is 1,0,0,1,0,0\n */\nexport const isIdentity = (m: DOMMatrix) => {\n    return (\n        m.a === 1 && m.b === 0 && m.c === 0 && m.d === 1 && m.e === 0 && m.f === 0\n    )\n}\n\n/**\n * This function tries to return a `DOMMatrix` that is the multiplication `m1 * m2`.\n * We also round to zero when it's near zero.\n * @function module:math.matrixMultiply\n * @param {...DOMMatrix} args - Matrix objects to multiply\n * @returns {DOMMatrix} The matrix object resulting from the calculation\n */\nexport const matrixMultiply = (...args: DOMMatrix[]): DOMMatrix => {\n    const m = args.reduceRight((prev, m1) => {\n        return m1.multiply(prev)\n    })\n\n    if (Math.abs(m.a) < NEAR_ZERO) {\n        m.a = 0\n    }\n    if (Math.abs(m.b) < NEAR_ZERO) {\n        m.b = 0\n    }\n    if (Math.abs(m.c) < NEAR_ZERO) {\n        m.c = 0\n    }\n    if (Math.abs(m.d) < NEAR_ZERO) {\n        m.d = 0\n    }\n    if (Math.abs(m.e) < NEAR_ZERO) {\n        m.e = 0\n    }\n    if (Math.abs(m.f) < NEAR_ZERO) {\n        m.f = 0\n    }\n\n    return m\n}\n\n/**\n * See if the given transformlist includes a non-indentity matrix transform.\n * @function module:math.hasMatrixTransform\n * @param {SVGTransformList} [tlist] - The transformlist to check\n * @returns {boolean} Whether or not a matrix transform was found\n */\nexport const hasMatrixTransform = (tlist: SVGTransformList) => {\n    if (!tlist) {\n        return false\n    }\n    let num = tlist.numberOfItems\n    while (num--) {\n        const xform = tlist.getItem(num)\n        if (xform.type === 1 && !isIdentity(xform.matrix)) {\n            return true\n        }\n    }\n    return false\n}\n\n/**\n * @typedef {PlainObject} module:math.TransformedBox An object with the following values\n * @property {module:math.XYObject} tl - The top left coordinate\n * @property {module:math.XYObject} tr - The top right coordinate\n * @property {module:math.XYObject} bl - The bottom left coordinate\n * @property {module:math.XYObject} br - The bottom right coordinate\n * @property {PlainObject} aabox - Object with the following values:\n * @property {Float} aabox.x - Float with the axis-aligned x coordinate\n * @property {Float} aabox.y - Float with the axis-aligned y coordinate\n * @property {Float} aabox.width - Float with the axis-aligned width coordinate\n * @property {Float} aabox.height - Float with the axis-aligned height coordinate\n */\nexport interface TransformedBox {\n    tl: Point,\n    tr: Point,\n    br: Point,\n    bl: Point,\n    aabox: {\n        x: number,\n        y: number,\n        width: number,\n        height: number\n    }\n}\n\n/**\n * Returns a 45 degree angle coordinate associated with the two given\n * coordinates.\n * @function module:math.snapToAngle\n * @param {Integer} x1 - First coordinate's x value\n * @param {Integer} y1 - First coordinate's y value\n * @param {Integer} x2 - Second coordinate's x value\n * @param {Integer} y2 - Second coordinate's y value\n * @returns {module:math.AngleCoord45}\n */\nexport const snapToAngle = (x1: number, y1: number, x2: number, y2: number) => {\n    const snap = Math.PI / 4 // 45 degrees\n    const dx = x2 - x1\n    const dy = y2 - y1\n    const angle = Math.atan2(dy, dx)\n    const dist = Math.sqrt(dx * dx + dy * dy)\n    const snapangle = Math.round(angle / snap) * snap\n\n    return {\n        x: x1 + dist * Math.cos(snapangle),\n        y: y1 + dist * Math.sin(snapangle),\n        a: snapangle\n    }\n}\n\n/**\n * Check if two rectangles (BBoxes objects) intersect each other.\n * @function module:math.rectsIntersect\n * @param {SVGRect} r1 - The first BBox-like object\n * @param {SVGRect} r2 - The second BBox-like object\n * @returns {boolean} True if rectangles intersect\n */\nexport const rectsIntersect = (r1: SVGRect, r2: SVGRect) => {\n    return (\n        r2.x < r1.x + r1.width &&\n        r2.x + r2.width > r1.x &&\n        r2.y < r1.y + r1.height &&\n        r2.y + r2.height > r1.y\n    )\n}\n\nexport const toTransformBox = (\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    angle: number = 0,\n    origin?: Point,\n): TransformedBox => {\n    const org = origin ? origin : point(x + (width / 2), y + (height / 2))\n    const [tl, tr, br, bl] = rotatePoints([\n        point(x, y),\n        point(x + width, y),\n        point(x + width, y + height),\n        point(x, y + height)\n    ], -angle, org)\n\n    const minx = Math.min(tl.x, tr.x, bl.x, br.x)\n    const maxx = Math.max(tl.x, tr.x, bl.x, br.x)\n    const miny = Math.min(tl.y, tr.y, bl.y, br.y)\n    const maxy = Math.max(tl.y, tr.y, bl.y, br.y)\n\n    return {\n        tl,\n        tr,\n        br,\n        bl,\n        aabox: {\n            x: minx,\n            y: miny,\n            width: maxx - minx,\n            height: maxy - miny\n        }\n    }\n}\n\nexport const svgInfo = (\n    ref: SVGSVGElement,\n    _props: '*' | 'width' | 'height' | 'viewBox' = \"*\"\n) => {\n    const svg = ref\n    const box = svg.getBBox()\n    const viewBox = [box.x, box.y, box.width, box.height].join(\" \")\n    const vX = box.x\n    const vY = box.y\n    const vWidth = box.width\n    const vHeight = box.height\n    const width = svg.width.baseVal.value\n    const height = svg.height.baseVal.value\n    const x = svg.x.baseVal.value\n    const y = svg.y.baseVal.value\n\n    return {\n        x,\n        y,\n        width,\n        height,\n        viewBox,\n        vX,\n        vY,\n        vWidth,\n        vHeight,\n    }\n}"],"names":["lineEquation","p1","p2","m","y","x","c","linesDistance","l1","l2","Math","abs","sqrt","distancePointFromLine","p","ls","le","reflectPointOverLine","line","point","arguments","length","Array","isArray","Object","freeze","zeroAjsPoint","NEAR_ZERO","CmpPoint","LESS","EQUAL","MORE","OTHER","cmpPoint","roundPoint","round","absPoint","addPoint","subPoint","divPoint","mulPoint","rotatePoint","angle","origin","radians","PI","cos","sin","rotatePoints","points","map","transformPoint","a","e","b","d","f","transformPoints","isIdentity","matrixMultiply","args","reduceRight","prev","m1","multiply","hasMatrixTransform","tlist","num","numberOfItems","xform","getItem","type","matrix","snapToAngle","x1","y1","x2","y2","snap","dx","dy","atan2","dist","snapangle","rectsIntersect","r1","r2","width","height","toTransformBox","org","tl","tr","br","bl","minx","min","maxx","max","miny","maxy","aabox","svgInfo","ref","_props","svg","box","getBBox","viewBox","join","vX","vY","vWidth","vHeight","baseVal","value"],"mappings":"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"}