{"version":3,"file":"geometry-9V4N-zFM.cjs","sources":["../src/math/point.ts","../src/math/matrix.ts","../src/math/geometry.ts"],"sourcesContent":["export interface Point { x: number, y: number }\nexport function point(value: [number, number]): Point\nexport function point(value: Point): Point\nexport function point(x: number, y: number): Point\nexport function point() {\n    return arguments.length === 1 ?\n        Array.isArray(arguments[0]) ? Object.freeze({ x: arguments[0][0], y: arguments[0][1] })\n            : Object.freeze({ x: arguments[0].x, y: arguments[0].y })\n        :\n        Object.freeze({ x: arguments[0], y: arguments[1] })\n}\nexport const zeroAjsPoint = (point: Point) => {\n    const NEAR_ZERO = 1e-10\n\n    return Object.freeze({\n        x: Math.abs(point.x) < NEAR_ZERO ? 0 : point.x,\n        y: Math.abs(point.y) < NEAR_ZERO ? 0 : point.y,\n    })\n}\nexport enum CmpPoint {\n    LESS = -1,\n    EQUAL = 0,\n    MORE = 1,\n    OTHER = 2,\n}\nexport const cmpPoint = (p1: Point, p2: Point) => (p1.x === p2.x && p1.y === p2.y) ?\n    CmpPoint.EQUAL : (p1.x > p2.x && p1.y > p2.y) ?\n        CmpPoint.MORE : (p1.x < p2.x && p1.y < p2.y) ?\n            CmpPoint.LESS : CmpPoint.OTHER\nexport const roundPoint = (point: Point) => Object.freeze({ x: Math.round(point.x), y: Math.round(point.y) })\nexport const absPoint = (point: Point) => Object.freeze({ x: Math.abs(point.x), y: Math.abs(point.y) })\nexport const addPoint = (p2: Point, p1: Point) => Object.freeze({ x: p2.x + p1.x, y: p2.y + p1.y })\nexport const subPoint = (p2: Point, p1: Point) => Object.freeze({ x: p2.x - p1.x, y: p2.y - p1.y })\nexport const divPoint = (p2: Point, p1: Point) => Object.freeze({ x: p2.x / p1.x, y: p2.y / p1.y })\nexport const mulPoint = (p2: Point, p1: Point) => Object.freeze({ x: p2.x * p1.x, y: p2.y * p1.y })\nexport const rotatePoint = (point: Point, angle: number, origin: Point) => {\n    const radians = (Math.PI / 180) * angle\n    const cos = Math.cos(radians)\n    const sin = Math.sin(radians)\n\n    return Object.freeze({\n        x: cos * (point.x - origin.x) + sin * (point.y - origin.y) + origin.x,\n        y: cos * (point.y - origin.y) - sin * (point.x - origin.x) + origin.y\n    })\n}\nexport const rotatePoints = (points: Point[], angle: number, origin: Point) => {\n    return points.map(point => rotatePoint(point, angle, origin))\n}","import { point, Point, rotatePoints } from './point'\n\n/**\n * Mathematical utilities.\n * @module math\n * @license MIT\n *\n * @copyright 2010 Alexis Deveria, 2010 Jeff Schiller\n */\n\n/**\n * @typedef {PlainObject} module:math.AngleCoord45\n * @property {Float} x - The angle-snapped x value\n * @property {Float} y - The angle-snapped y value\n * @property {Integer} a - The angle at which to snap\n */\n\n/**\n * @typedef {PlainObject} module:math.XYObject\n * @property {Float} x\n * @property {Float} y\n */\n\n// Constants\nconst NEAR_ZERO = 1e-14\n\n\n/**\n * A (hopefully) quicker function to transform a point by a matrix\n * (this function avoids any DOM calls and just does the math).\n * @function module:math.transformPoint\n * @param {Point} point - Float representing the x coordinate\n * @param {DOMMatrix} m - Matrix object to transform the point with\n * @returns {module:Point} representing the transformed point\n */\nexport const transformPoint = (m: DOMMatrix, p: Point) =>\n    point(m.a * p.x + m.c * p.y + m.e, m.b * p.x + m.d * p.y + m.f)\n\n/**\n * Calculate an array of points transformed with an affine matrix\n * @function module:math.transformPoints\n * @param {DOMMatrix} matrix Affine Matrix\n * @param {Point[]} points Array of point\n * @returns {Point[]} Array of point\n */\nexport const transformPoints = (m: DOMMatrix, points: Point[]) => {\n    return points.map(point => transformPoint(m, point))\n}\n\n/**\n * Helper function to check if the matrix performs no actual transform\n * (i.e. exists for identity purposes).\n * @function module:math.isIdentity\n * @param {DOMMatrix} m - The matrix object to check\n * @returns {boolean} Indicates whether or not the matrix is 1,0,0,1,0,0\n */\nexport const isIdentity = (m: DOMMatrix) => {\n    return (\n        m.a === 1 && m.b === 0 && m.c === 0 && m.d === 1 && m.e === 0 && m.f === 0\n    )\n}\n\n/**\n * This function tries to return a `DOMMatrix` that is the multiplication `m1 * m2`.\n * We also round to zero when it's near zero.\n * @function module:math.matrixMultiply\n * @param {...DOMMatrix} args - Matrix objects to multiply\n * @returns {DOMMatrix} The matrix object resulting from the calculation\n */\nexport const matrixMultiply = (...args: DOMMatrix[]): DOMMatrix => {\n    const m = args.reduceRight((prev, m1) => {\n        return m1.multiply(prev)\n    })\n\n    if (Math.abs(m.a) < NEAR_ZERO) {\n        m.a = 0\n    }\n    if (Math.abs(m.b) < NEAR_ZERO) {\n        m.b = 0\n    }\n    if (Math.abs(m.c) < NEAR_ZERO) {\n        m.c = 0\n    }\n    if (Math.abs(m.d) < NEAR_ZERO) {\n        m.d = 0\n    }\n    if (Math.abs(m.e) < NEAR_ZERO) {\n        m.e = 0\n    }\n    if (Math.abs(m.f) < NEAR_ZERO) {\n        m.f = 0\n    }\n\n    return m\n}\n\n/**\n * See if the given transformlist includes a non-indentity matrix transform.\n * @function module:math.hasMatrixTransform\n * @param {SVGTransformList} [tlist] - The transformlist to check\n * @returns {boolean} Whether or not a matrix transform was found\n */\nexport const hasMatrixTransform = (tlist: SVGTransformList) => {\n    if (!tlist) {\n        return false\n    }\n    let num = tlist.numberOfItems\n    while (num--) {\n        const xform = tlist.getItem(num)\n        if (xform.type === 1 && !isIdentity(xform.matrix)) {\n            return true\n        }\n    }\n    return false\n}\n\n/**\n * @typedef {PlainObject} module:math.TransformedBox An object with the following values\n * @property {module:math.XYObject} tl - The top left coordinate\n * @property {module:math.XYObject} tr - The top right coordinate\n * @property {module:math.XYObject} bl - The bottom left coordinate\n * @property {module:math.XYObject} br - The bottom right coordinate\n * @property {PlainObject} aabox - Object with the following values:\n * @property {Float} aabox.x - Float with the axis-aligned x coordinate\n * @property {Float} aabox.y - Float with the axis-aligned y coordinate\n * @property {Float} aabox.width - Float with the axis-aligned width coordinate\n * @property {Float} aabox.height - Float with the axis-aligned height coordinate\n */\nexport interface TransformedBox {\n    tl: Point,\n    tr: Point,\n    br: Point,\n    bl: Point,\n    aabox: {\n        x: number,\n        y: number,\n        width: number,\n        height: number\n    }\n}\n\n/**\n * Returns a 45 degree angle coordinate associated with the two given\n * coordinates.\n * @function module:math.snapToAngle\n * @param {Integer} x1 - First coordinate's x value\n * @param {Integer} y1 - First coordinate's y value\n * @param {Integer} x2 - Second coordinate's x value\n * @param {Integer} y2 - Second coordinate's y value\n * @returns {module:math.AngleCoord45}\n */\nexport const snapToAngle = (x1: number, y1: number, x2: number, y2: number) => {\n    const snap = Math.PI / 4 // 45 degrees\n    const dx = x2 - x1\n    const dy = y2 - y1\n    const angle = Math.atan2(dy, dx)\n    const dist = Math.sqrt(dx * dx + dy * dy)\n    const snapangle = Math.round(angle / snap) * snap\n\n    return {\n        x: x1 + dist * Math.cos(snapangle),\n        y: y1 + dist * Math.sin(snapangle),\n        a: snapangle\n    }\n}\n\n/**\n * Check if two rectangles (BBoxes objects) intersect each other.\n * @function module:math.rectsIntersect\n * @param {SVGRect} r1 - The first BBox-like object\n * @param {SVGRect} r2 - The second BBox-like object\n * @returns {boolean} True if rectangles intersect\n */\nexport const rectsIntersect = (r1: SVGRect, r2: SVGRect) => {\n    return (\n        r2.x < r1.x + r1.width &&\n        r2.x + r2.width > r1.x &&\n        r2.y < r1.y + r1.height &&\n        r2.y + r2.height > r1.y\n    )\n}\n\nexport const toTransformBox = (\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    angle: number = 0,\n    origin?: Point,\n): TransformedBox => {\n    const org = origin ? origin : point(x + (width / 2), y + (height / 2))\n    const [tl, tr, br, bl] = rotatePoints([\n        point(x, y),\n        point(x + width, y),\n        point(x + width, y + height),\n        point(x, y + height)\n    ], -angle, org)\n\n    const minx = Math.min(tl.x, tr.x, bl.x, br.x)\n    const maxx = Math.max(tl.x, tr.x, bl.x, br.x)\n    const miny = Math.min(tl.y, tr.y, bl.y, br.y)\n    const maxy = Math.max(tl.y, tr.y, bl.y, br.y)\n\n    return {\n        tl,\n        tr,\n        br,\n        bl,\n        aabox: {\n            x: minx,\n            y: miny,\n            width: maxx - minx,\n            height: maxy - miny\n        }\n    }\n}\n\nexport const svgInfo = (\n    ref: SVGSVGElement,\n    _props: '*' | 'width' | 'height' | 'viewBox' = \"*\"\n) => {\n    const svg = ref\n    const box = svg.getBBox()\n    const viewBox = [box.x, box.y, box.width, box.height].join(\" \")\n    const vX = box.x\n    const vY = box.y\n    const vWidth = box.width\n    const vHeight = box.height\n    const width = svg.width.baseVal.value\n    const height = svg.height.baseVal.value\n    const x = svg.x.baseVal.value\n    const y = svg.y.baseVal.value\n\n    return {\n        x,\n        y,\n        width,\n        height,\n        viewBox,\n        vX,\n        vY,\n        vWidth,\n        vHeight,\n    }\n}\n\nexport class Transform {\n    x: number\n    y: number\n    rotate: number\n    scaleX: number\n    scaleY: number\n\n    constructor(transform: string) {\n        this.x = 0\n        this.y = 0\n        this.scaleX = 1\n        this.scaleY = 1\n        this.rotate = 0\n        this.#parse(transform)\n    }\n    \n    public get transform(): {x: number, y: number, rotate: number, scaleX: number, scaleY: number } { \n        return { x: this.x, y: this.y, rotate: this.rotate, scaleX: this.scaleX, scaleY: this.scaleY }\n    }\n    public set transform(transform: string) { this.#parse(transform) }\n\n    #parse(transform: string) {\n        if (transform) {\n            const transformTrim = transform.replace(/, /g, ',')\n            .replace(/px/g, '')\n            const translate = /translate\\(\\s*([^\\s,)]+)[ ,]([^\\s,)]+)/.exec(transformTrim)\n            const scale2d = /scale\\(\\s*([^\\s,)]+)[ ,]([^\\s,)]+)/.exec(transformTrim)\n            const rotate = /rotate\\(\\s*([^\\s,)]+)/.exec(transformTrim)\n\n            if(translate) {\n                this.x = +translate[1]\n                this.y = +translate[2]\n            }\n\n            if(scale2d) {\n                this.scaleX = +scale2d[1]\n                this.scaleY = +scale2d[2]\n            } else {\n                const scale = /scale\\(\\s*([^\\s,)]+)/.exec(transformTrim)\n                if(scale) {\n                    this.scaleX = +scale[1]\n                    this.scaleY = +scale[1]\n                }\n            }\n\n            if(rotate) {\n                this.rotate = +rotate[1]\n            }\n        }\n    }\n}","import { Point } from \"./point\"\n\nexport type LineEquation = { m: number, c: number }\nexport const lineEquation = (p1: Point, p2: Point): LineEquation => {\n    const m = (p2.y - p1.y) / (p2.x - p1.x)\n    const c = p1.y - m * p1.x\n    return { m, c }\n}\nexport const linesDistance = (l1: LineEquation, l2: LineEquation) => {\n    return Math.abs(l2.c - l1.c) / Math.sqrt(1 + l1.m ** 2)\n}\nexport const distancePointFromLine = (p: Point, ls: Point, le: Point) => {\n    return (\n        (le.x - ls.x) * (ls.y - p.y) - (le.y - ls.y) * (ls.x - p.x)\n    ) / Math.sqrt((le.x - ls.x) ** 2 + (le.y - ls.y) ** 2)\n}\nexport const reflectPointOverLine = (line: LineEquation, point: Point) => {\n    return {\n        x: (point.x + line.m * (point.y - line.c)) / (1 + line.m ** 2),\n        y: (line.m * point.x - point.y + 2 * line.c) / (1 + line.m ** 2),\n    }\n}"],"names":["point","arguments","length","Array","isArray","Object","freeze","x","y","zeroAjsPoint","Math","abs","NEAR_ZERO","CmpPoint","LESS","EQUAL","MORE","OTHER","cmpPoint","p1","p2","roundPoint","round","absPoint","addPoint","subPoint","divPoint","mulPoint","rotatePoint","angle","origin","radians","PI","cos","sin","rotatePoints","points","map","transformPoint","m","p","a","c","e","b","d","f","transformPoints","isIdentity","matrixMultiply","args","reduceRight","prev","m1","multiply","hasMatrixTransform","tlist","num","numberOfItems","xform","getItem","type","matrix","snapToAngle","x1","y1","x2","y2","snap","dx","dy","atan2","dist","sqrt","snapangle","rectsIntersect","r1","r2","width","height","toTransformBox","org","tl","tr","br","bl","minx","min","maxx","max","miny","maxy","aabox","svgInfo","ref","_props","svg","box","getBBox","viewBox","join","vX","vY","vWidth","vHeight","baseVal","value","Transform","constructor","transform","__privateAdd","_parse","rotate","scaleX","scaleY","__privateMethod","parse_fn","transformTrim","replace","translate","exec","scale2d","scale","lineEquation","linesDistance","l1","l2","distancePointFromLine","ls","le","reflectPointOverLine","line"],"mappings":"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"}